# 🔔 모던 자바스크립트 Deep Dive 25장(1)

**25장 클래스**

```
25-1. 클래스는 프로토타입의 문법적 설탕인가?
    - 자바스크립트는 프로토타입 기반 객체지향 언어다.
      프로토타입 기반 객체지향 언어는 클래스가 필요없는 객체지향 프로그래밍언어다.
      하지만 클래스 기반 언어에 익숙한 프로그래머들은 프로토타입 기반 프로그래밍 방식에
      혼란을 느낄 수 있으며, 자바스크립트를 어렵게 느끼게 하는 하나의 장벽이다.
    - ES6에선 클래스가 도입되어 기존 프로토타입 기반 객체지향 프로그래밍보다 클래스 기반
      객체지향 프로그래밍에 익숙한 프로그래머가 더욱 빠르게 학습할 수 있도록
      클래스 기반 객체지향 프로그래밍언어와 매우 흡사한 새로운 객체 생성 메커니즘을 제시한다.
    - 클래스와 생성자 함수는 프로토타입 기반의 인스턴스를 생성하지만 동일하게 동작하진않는다.
      클래스가 더 엄격하며 생성자 함수에서 제공하지 않는 기능도 있다.
        > 클래스를 new 연산자 없이 호출하면 에러가 발생 ( 생성자 함수는 일반함수로 호출됨. )
          클래스는 상속을 지원하는 extends와 super키워드를 제공한다.
          클래스는 호이스팅이 발생하지 않는것처럼 동작한다.
          ( 정확히는 let,const처럼 일시적 사각지대가 생김 )
          클래스 내의 모든 코드에는 암묵적으로 strict mode가 지정되어 실행된다.
          클래스의 constructor, 프로토타입 메서드, 정적메서드는 [[Enumerable]]의 값이 false다.
          ( 즉 열거되지 않는다 )

25-2. 클래스 정의
    - class 키워드를 사용하여 정의하며 PascalCase를 사용한다.
    - 클래스는 일급객체이다.
        > 무명의 리터럴로 생성할 수 있다. 즉, 런타임에 생성이 가능하다.
          변수나 자료구조(객체,배열)에 저장할 수 있다.
          parameter로 전달할 수 있다.
          반환값으로 사용할 수 있다.
    - 클래스 몸체에는 0개이상의 메서드만 정의할 수 있다.
        > constructor
          프로토타입 메서드
          정적 메서드

25-3. 클래스 호이스팅
    - 클래스 선언문으로 정의한 클래스는 런타임 이전에 먼저 평가되어 함수 객체를 생성한다.
      이때 클래스가 평가되어 생성된 함수 객체는 constructor다.
      constructor함수는 함수 정의가 평가되어 함수 객체를 생성하는 시점에 프로토타입도 더불어 생성된다.
      프로토타입과 생성자 함수는 단독으로 존재할 수 없고 언제나 쌍으로 존재하기 때문이다.
      단, 클래스는 클래스 정의 이전에 참조할 수 없다.
      클래스는 let,const키워드로 선언한 변수처럼 선언문 이전에 일시적 사각지대에 빠지기 떄문이다.

25-4. 인스턴스 생성
    - 클래스는 new연산자와 함께 호출되어 인스턴스를 생성한다.
    - 클래스는 반드시 new 연산자와 함께 호출한다.

25-5. 메서드
    - 클래스 몸체에는 0개 이상의 메서드만 선언할 수 있다.
      constructor,프로토타입 메서드,정적 메서드 세가지다.
    - constructor
        > 인스턴스를 생성하고 초기화하기 위한 특수한 메서드다.
          클래스는 함수객체가 되고 함수 객체 고유의 프로퍼티를 모두 갖고있다.
          함수객체가 갖고 있는 prototype 프로퍼티가 가리키는 프로토타입 객체의
          constructor 프로퍼티는 클래스 자신을 가리키고 있다.
          이는 클래스가 생성자 함수라는 것을 의미한다.
          constructor내부의 this는 클래스가 생성한 인스턴스를 가리킨다.
          constructor는 클래스가 평가되어 생성한 생성한 함수 객체 코드의 일부가 된다.
          constructor는 클래스 내에 최대 한 개만 존재한다.
          constructor는 생략하면 빈 객체를 생성한다.
          constructor 내부에서 this에 인스턴스 프로퍼티를 추가하면 인스턴스에 프로퍼티가 추가되고
          초기화 된 인스턴스를 생성한다.
          인스턴스를 생성할 때 인스턴스 프로퍼티의 초기값을 전달하려면 constructor parameter를 선언하고,
          인스턴스를 생성할 때 초기값을 argument로 전달한다.
          이처럼 constructor내에서는 인스턴스의 생성과 동시에 인스턴스 프로퍼티 추가를 통해
          인스턴스의 초기화를 실행하고, constructor는 return문이 없어야 한다.
    - 프로토타입 메서드
        > 클래스 몸체에서 정의한 메서드는 클래스의 prototype 프로퍼티에 메서드를 추가하지 않아도
          기본적으로 프로토타입 메서드가 된다.
          프로토타입 체인은 클래스에 의해 생성된 인스턴스에도 동일하게 적용된다.
    - 정적 메서드
        > 정적 메서드는 인스턴스를 생성하지 않아도 호출할 수 있는 메서드
          클래스에서는 메서드에 static 키워드를 붙이면 정적메서드가 된다.
          정적메서드는 클래스에 바인딩된 메서드가 된다.
          정적 메서드는 클래스로 호출하고, 인스턴스로 호출할 수 없다.
          ( 정적 메서드가 바인딩된 클래스는 인스턴스의 프로토타입 체인상에 존재하지 않기 때문 )
    - 정적메서드와 프로토타입 메서드의 차이
        > 정적메서드와 프로토타입 메서드는 속해 있는 프로토타입 체인이 다르다.
          정적메서드는 클래스로 호출, 프로토타입 메서드는 인스턴스로 호출한다.
          정적 메서드는 인스턴스 프로퍼티(this.---)를 참조할 수 없지만,
          프로토타입 메서드는 인스턴스 프로퍼티(this.---)를 참조할 수 있다.
          즉, this를 사용하지 않는 메서드는 정적 메서드로 정의하는것이 좋다.
          클래스 또는 생성자 함수를 하나의 네임스페이스로 사용하여 정적 메서드를 모아 놓으면
          이름 충돌 가능성을 줄여 주고 관련 함수들을 구조화할 수 있는 효과가 있다.
    - 클래스에서 정의한 메서드의 특징
        > 메서드 축약 표현을 사용한다.
          암묵적으로 strict mode로 실행된다.
          열거할 수 없다
          non-constructor다. ( new 연산자와 함께 호출할 수 없다 )

25-6. 클래스의 인스턴스 생성 과정
    - new 연산자와 함께 클래스를 호출하면 클래스의 내부 메서드 [[Construct]]가 호출된다.
      그럼 빈 객체(인스턴스)가 생성되고, 인스턴스의 프로토타입으로 클래스의 prototype 프로퍼티가
      가리키는 객체가 바인딩 된다. 그리고 인스턴스는 this에 바인딩 된다.
      constructor의 내부 코드가 실행되어 인스턴스에 프로퍼티를 추가하고 constructor가
      인수로 전달받은 초기값으로 인스턴스의 프로퍼티값을 초기화한다.
      클래스의 모든 처리가 끝나면 완성된 인스턴스가 반환된다.

```
